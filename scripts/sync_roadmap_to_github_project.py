#!/usr/bin/env python3
"""Sync semantic roadmap nodes into a GitHub Project (ProjectV2).

Design goals:
- Idempotent updates keyed by managed title prefix: `SR:<node_id> | ...`
- Safe default (dry-run). Use --apply to mutate project state.
- Minimal field mapping: Status, Priority, Target date.
"""

from __future__ import annotations

import argparse
import json
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any


ROOT = Path(__file__).resolve().parents[1]
DEFAULT_MODEL = ROOT / "docs" / "roadmap" / "semantic-roadmap.json"
MANAGED_PREFIX = "SR:"

DEFAULT_KINDS = {"initiative", "work_item", "milestone"}


@dataclass
class FieldInfo:
    id: str
    options: dict[str, str]


class SyncError(Exception):
    """Raised for sync failures."""


def run_gh(args: list[str], expect_json: bool = False) -> Any:
    cmd = ["gh", *args]
    try:
        result = subprocess.run(
            cmd,
            check=True,
            text=True,
            capture_output=True,
        )
    except subprocess.CalledProcessError as exc:
        raise SyncError(f"Command failed: {' '.join(cmd)}\n{exc.stderr.strip()}") from exc
    out = result.stdout.strip()
    if expect_json:
        if not out:
            return {}
        return json.loads(out)
    return out


def load_model(path: Path) -> dict[str, Any]:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def get_project_meta(owner: str, number: int) -> tuple[str, dict[str, FieldInfo]]:
    project = run_gh(
        ["project", "view", str(number), "--owner", owner, "--format", "json"],
        expect_json=True,
    )
    project_id = project["id"]

    fields_raw = run_gh(
        ["project", "field-list", str(number), "--owner", owner, "--format", "json"],
        expect_json=True,
    )
    fields: dict[str, FieldInfo] = {}
    for f in fields_raw.get("fields", []):
        name = f["name"]
        options = {}
        for opt in f.get("options", []):
            options[opt["name"]] = opt["id"]
        fields[name] = FieldInfo(id=f["id"], options=options)

    required = ["Status", "Priority", "Target date"]
    missing = [name for name in required if name not in fields]
    if missing:
        raise SyncError(f"Project is missing required fields: {', '.join(missing)}")
    return project_id, fields


def list_items(owner: str, number: int) -> list[dict[str, Any]]:
    payload = run_gh(
        ["project", "item-list", str(number), "--owner", owner, "--format", "json"],
        expect_json=True,
    )
    return payload.get("items", [])


def desired_title(node: dict[str, Any]) -> str:
    return f"{MANAGED_PREFIX}{node['id']} | {node['title']}"


def extract_managed_node_id(title: str) -> str | None:
    if not title.startswith(MANAGED_PREFIX):
        return None
    rest = title[len(MANAGED_PREFIX) :]
    if " | " not in rest:
        return None
    return rest.split(" | ", 1)[0].strip()


def map_status(value: str) -> str:
    return {
        "planned": "Todo",
        "in_progress": "In progress",
        "blocked": "Todo",
        "done": "Done",
        "deprecated": "Done",
    }.get(value, "Todo")


def map_priority(value: str) -> str:
    return {
        "P0": "P0",
        "P1": "P1",
        "P2": "P2",
        "P3": "P2",
    }.get(value, "P2")


def make_body(model: dict[str, Any], node: dict[str, Any]) -> str:
    lines = []
    lines.append(f"Canonical roadmap node: `{node['id']}`")
    lines.append("")
    lines.append(f"- Program: {model['program']}")
    lines.append(f"- Roadmap: `{model['roadmap_id']}` v{model['version']} (as_of {model['as_of']})")
    lines.append(f"- Kind: `{node.get('kind', '')}`")
    lines.append(f"- Status: `{node.get('status', '')}`")
    lines.append(f"- Priority: `{node.get('priority', '')}`")
    lines.append(f"- Horizon: `{node.get('horizon', '')}`")
    lines.append(f"- Owner: `{node.get('owner', '')}`")
    lines.append("")
    summary = node.get("summary", "").strip()
    if summary:
        lines.append("## Summary")
        lines.append(summary)
        lines.append("")
    source_docs = node.get("source_docs", [])
    if source_docs:
        lines.append("## Source Docs")
        for src in source_docs:
            lines.append(f"- {src}")
        lines.append("")
    lines.append("Generated by `scripts/sync_roadmap_to_github_project.py`.")
    return "\n".join(lines)


def edit_single_select(
    *,
    apply: bool,
    project_id: str,
    item_id: str,
    field_id: str,
    option_id: str,
    label: str,
) -> None:
    if not apply:
        print(f"DRY-RUN: set {label} on {item_id} -> option {option_id}")
        return
    run_gh(
        [
            "project",
            "item-edit",
            "--id",
            item_id,
            "--project-id",
            project_id,
            "--field-id",
            field_id,
            "--single-select-option-id",
            option_id,
        ]
    )


def edit_date(
    *,
    apply: bool,
    project_id: str,
    item_id: str,
    field_id: str,
    date_value: str | None,
    label: str,
) -> None:
    if not date_value:
        if not apply:
            print(f"DRY-RUN: clear {label} on {item_id}")
            return
        run_gh(
            [
                "project",
                "item-edit",
                "--id",
                item_id,
                "--project-id",
                project_id,
                "--field-id",
                field_id,
                "--clear",
            ]
        )
        return

    if not apply:
        print(f"DRY-RUN: set {label} on {item_id} -> {date_value}")
        return
    run_gh(
        [
            "project",
            "item-edit",
            "--id",
            item_id,
            "--project-id",
            project_id,
            "--field-id",
            field_id,
            "--date",
            date_value,
        ]
    )


def upsert_item(
    *,
    apply: bool,
    owner: str,
    project_number: int,
    project_id: str,
    fields: dict[str, FieldInfo],
    model: dict[str, Any],
    node: dict[str, Any],
    existing_item: dict[str, Any] | None,
) -> str:
    target_title = desired_title(node)
    body = make_body(model, node)
    item_id: str
    draft_content_id: str | None = None

    if existing_item:
        item_id = existing_item["id"]
        draft_content_id = existing_item.get("content", {}).get("id")
        current_title = existing_item.get("title", "")
        if current_title != target_title:
            if not draft_content_id:
                print(f"WARN: cannot update title for non-draft item {item_id}")
            elif not apply:
                print(f"DRY-RUN: update title {draft_content_id}: '{current_title}' -> '{target_title}'")
            else:
                run_gh(["project", "item-edit", "--id", draft_content_id, "--title", target_title])
        # NOTE: gh CLI currently fails on body-only updates for draft issues
        # ("Title can't be blank"), so body is set on create and left unchanged
        # on update.
    else:
        if not apply:
            print(f"DRY-RUN: create draft item '{target_title}'")
            item_id = f"dry-run:{node['id']}"
        else:
            created = run_gh(
                [
                    "project",
                    "item-create",
                    str(project_number),
                    "--owner",
                    owner,
                    "--title",
                    target_title,
                    "--body",
                    body,
                    "--format",
                    "json",
                ],
                expect_json=True,
            )
            item_id = created["id"]
            print(f"Created: {target_title} ({item_id})")

    status_name = map_status(node.get("status", "planned"))
    priority_name = map_priority(node.get("priority", "P2"))
    status_option_id = fields["Status"].options.get(status_name)
    priority_option_id = fields["Priority"].options.get(priority_name)
    if not status_option_id:
        raise SyncError(f"Project Status option missing: {status_name}")
    if not priority_option_id:
        raise SyncError(f"Project Priority option missing: {priority_name}")

    edit_single_select(
        apply=apply,
        project_id=project_id,
        item_id=item_id,
        field_id=fields["Status"].id,
        option_id=status_option_id,
        label="Status",
    )
    edit_single_select(
        apply=apply,
        project_id=project_id,
        item_id=item_id,
        field_id=fields["Priority"].id,
        option_id=priority_option_id,
        label="Priority",
    )
    edit_date(
        apply=apply,
        project_id=project_id,
        item_id=item_id,
        field_id=fields["Target date"].id,
        date_value=node.get("due_date"),
        label="Target date",
    )
    return item_id


def sync(
    *,
    owner: str,
    project_number: int,
    model_path: Path,
    apply: bool,
    archive_stale: bool,
    kinds: set[str],
) -> None:
    model = load_model(model_path)
    project_id, fields = get_project_meta(owner, project_number)
    items = list_items(owner, project_number)

    managed_by_node_id: dict[str, dict[str, Any]] = {}
    for item in items:
        node_id = extract_managed_node_id(item.get("title", ""))
        if node_id:
            managed_by_node_id[node_id] = item

    desired_nodes = [n for n in model.get("nodes", []) if n.get("kind") in kinds]
    desired_nodes.sort(key=lambda n: (n.get("kind", ""), n.get("priority", ""), n.get("title", "")))
    desired_ids = {n["id"] for n in desired_nodes}

    print(f"Project #{project_number} owner={owner} project_id={project_id}")
    print(f"Managed existing items: {len(managed_by_node_id)}")
    print(f"Desired nodes to sync: {len(desired_nodes)}")
    print(f"Mode: {'APPLY' if apply else 'DRY-RUN'}")

    for node in desired_nodes:
        existing = managed_by_node_id.get(node["id"])
        upsert_item(
            apply=apply,
            owner=owner,
            project_number=project_number,
            project_id=project_id,
            fields=fields,
            model=model,
            node=node,
            existing_item=existing,
        )

    stale_ids = sorted(set(managed_by_node_id.keys()) - desired_ids)
    if stale_ids:
        print(f"Stale managed items: {len(stale_ids)}")
    for node_id in stale_ids:
        item = managed_by_node_id[node_id]
        item_id = item["id"]
        if archive_stale:
            if not apply:
                print(f"DRY-RUN: archive stale item {item_id} ({node_id})")
            else:
                run_gh(
                    [
                        "project",
                        "item-archive",
                        str(project_number),
                        "--owner",
                        owner,
                        "--id",
                        item_id,
                    ]
                )
                print(f"Archived stale item: {item_id} ({node_id})")
        else:
            print(f"Leave stale item untouched: {item_id} ({node_id})")


def main() -> int:
    parser = argparse.ArgumentParser(description="Sync semantic roadmap to GitHub Project.")
    parser.add_argument("--owner", default="BioregionalKnowledgeCommons")
    parser.add_argument("--project", type=int, default=1)
    parser.add_argument("--model", type=Path, default=DEFAULT_MODEL)
    parser.add_argument(
        "--kinds",
        default="initiative,work_item,milestone",
        help="Comma-separated node kinds to sync.",
    )
    parser.add_argument("--apply", action="store_true", help="Apply changes (default is dry-run).")
    parser.add_argument(
        "--archive-stale",
        action="store_true",
        help="Archive previously managed items no longer present in desired set.",
    )
    args = parser.parse_args()

    kinds = {k.strip() for k in args.kinds.split(",") if k.strip()}
    if not kinds:
        kinds = set(DEFAULT_KINDS)

    try:
        sync(
            owner=args.owner,
            project_number=args.project,
            model_path=args.model,
            apply=args.apply,
            archive_stale=args.archive_stale,
            kinds=kinds,
        )
    except SyncError as exc:
        print(f"ERROR: {exc}")
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
